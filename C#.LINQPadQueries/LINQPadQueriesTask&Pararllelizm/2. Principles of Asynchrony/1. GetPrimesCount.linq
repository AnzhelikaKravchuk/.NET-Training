<Query Kind="Program">
  <Namespace>System.Threading.Tasks</Namespace>
</Query>

//Синхронная функция выполняет свою работу перед возвратом 
//управления вызывающуму коду

//Асинхронная функция выполняет большую часть своей работы (или всю)
//после возврата управления вызывающему коду - инициируют параллелизм -
//неблокирующие методы

//Универсальные асинхронные методы
//Thread.Start
//Task.Run
//методы, присоединяющие признаки продолжения задач

//Принцип асинхронного программирования  - длительно выполняющиеся функции
//реализуются асинхронно. параллелизм инициируется внутри длительно 
//выполняющейся функции, а не за ее пределами
//Примущества
// - параллельное выполнение с длительным вводом-выводом может быть реализовано
//без дополнительного связывания потоков (эфективность и масштабируемость)
// - обогащенные клиентские приложения получают меньше кода в рабочих потоках,
//упрощая реализацию их безопасности

//Task - основа асинхронного программирования, т.к. они поддерживают 
//продолжения - существенно важные для реализации асинхронности

//Асинхронный метод создается за счет возврата задачи вызывающему коду

void Main()
{
	DisplayPrimeCounts();
}

void DisplayPrimeCounts()
{
	for (int i = 0; i < 10; i++)
		Console.WriteLine (GetPrimesCount (i*1000000 + 2, 1000000) +
			" primes between " + (i*1000000) + " and " + ((i+1)*1000000-1));
	
	Console.WriteLine ("Done!");
}

int GetPrimesCount (int start, int count)
{
	return
		//public static class ParallelEnumerable
		ParallelEnumerable.Range (start, count).Count (n => 
			Enumerable.Range (2, (int)Math.Sqrt(n)-1).All (i => n % i > 0));
}
<Query Kind="Statements" />

//Принцип единственности ответственности (Single Responsibility Principle)

//Формулировка: не должно быть больше одной причины для изменения класса
//Что является причиной изменения логики работы класса? Видимо, 
//изменение отношений между классами, введение новых требований
//или отмена старых. Вообще, вопрос о причине этих изменений 
//лежит в плоскости ответвенности, которую мы возложили на наш класс. 
//Если у объекта много ответвенности, то и меняться он будет очень часто.
//Таким образом, если класс имеет больше одной ответственности, 
//то это ведет к хрупкости дизайна и ошибкам в неожиданных местах 
//при изменениях кода

//Active Record
//Генерация по таблицам базы данных бизнес-сущностей. 
//Возьмем для примера сущность пользователя - Account. 
//Сценарий использования выглядит так:

// создание пользователя
Accounts account = new Accounts();
account.AddNew();
account.Name = "Name";
account.Save();
 
// загрузка объекта по Id
Accounts account = new Accounts();
account.LoadByPrimaryKey(1);
 
// загрузка связной коллекции при обращении к свойству объекта
var list = account.Roles;

//Шаблон Active Record может быть успешно использован в небольших проектах с
//простой бизнес-логикой. Практика показывает, что когда проект разрастается,
//то из-за смешанной логики внутри доменных объектов возникает много
//дублирования в коде и непредвиденных ошибок. Обращения к базе данных
//довольно сложно проследить, когда они скрыты, например, за свойством объекта account.Roles.
//
//В данном случае объект Account имеет несколько ответственностей:
//- является объектом домена и хранит бизнес-правила, например, 
//связь с коллекцией ролей
//- является точкой доступа к базе данных


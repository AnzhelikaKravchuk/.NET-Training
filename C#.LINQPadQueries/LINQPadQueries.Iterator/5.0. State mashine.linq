<Query Kind="Statements">
  <Reference>&lt;RuntimeDirectory&gt;\System.Dynamic.dll</Reference>
  <IncludePredicateBuilder>true</IncludePredicateBuilder>
</Query>

//http://habrahabr.ru/post/160105/
//http://stackoverflow.com/questions/5923767/simple-state-machine-example-in-c
//http://betamoore.wordpress.com/2012/03/21/c-state-machine-example/
//http://blog.abodit.com/2012/01/a-simple-state-machine-in-c/

//Когда речь идет об итераторных блоках, важно понимать, 
//что хотя пишется метод, который выглядит выполняющимся последовательно,
//в действительности у компилятора запрашивается создание конечного автомата

//Когда компилятор встречает итераторный блок, он создает вложенный тип,
//предназначенный для конечного автомата. Этот тип запоминает точное 
//местонахождеъше внутри блока и значения локальных переменных 
//(в том числе параметров). Сгенерированный класс отчасти похож 
//на написанную ранее длинную реализацию тем, что он сохраняет 
//все необходимое состояние в виде переменных экземпляра.
//Давайте подумаем о том, что этот конечный автомат должен делать 
//в плане реализации итератора.
// - Он должен иметь некоторое начальное состояние.
// - Всякий раз, когда вызывается метод MoveNext(), он должен вьполнять 
//   код из метода GetEnumerator() до тех пор, пока не будет готово
//   к предоставлению следующее значенне (другими словами, пока не 
//   будет достигнут оператор yield return).
// - Когда используется свойство Current, он должен возвратить последнее
//   выданное значение.
// - Он должен знать, когда выдача значений завершена, чтобы метод MoveNext() 
//мог возвратить false.

//Что такое конечный автомат состояний.
//
//В электронике, да и в программировании, в простейшем случае мы имеем дело 
//с так называемыми «переключательными функциями». Это относительно примитивная
//абстракция не имеющая собственной памяти: мы на вход аргумент, она на выход
//некое значение. Выходное значение всегда зависит только от входного.
//
//А если нам необходимо, чтобы последующее значение функции зависело от предыдущего?
//От нескольких предыдущих? Тут мы уже приходим к некой абстракции с собственной 
//памятью. Это и будет автомат. Выходное значение на автомате зависит от значения
//на входе и текущего состояния автомата.
//
//Конечный автомат соответственно потому так называется, что число его внутренних
//состояний конечно. А, наверное, самым простейшим из конечных автоматов является 
//детерминированный: для каждого входного сигнала существует лишь одно состояние,
//в которое автомат может перейти из текущего.
//
//Таким образом, автомат определяется следующим:
// - начальным состоянием;
// - набором возможных входных сигналов;
// - множеством состояний;
// - таблицей переходов.

//Собственно вся суть автомата определяется последним пунктом.
//Таблица переходов (также изображается как диаграмма переходов)
//состоит из 3-х столбцов: входной сигнал (символ), 
//текущее состояние, следующее состояние.
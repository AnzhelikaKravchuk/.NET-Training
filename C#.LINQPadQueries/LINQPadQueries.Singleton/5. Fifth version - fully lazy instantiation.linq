<Query Kind="Program">
  <Reference>&lt;RuntimeDirectory&gt;\System.Runtime.Serialization.dll</Reference>
</Query>

#region Fifth version
// Fifth version - fully lazy instantiation
#endregion

//Полностью «ленивая» реализация
public sealed class Singleton
{
	private Singleton(){ }

	public static Singleton Instance { get { return Nested.instance; } }
	
	// Именно вложенный класс делает реализацию полностью «ленивой»
	private class Nested
	{
		// Пустой статический конструктор уже не нужен, если мы будем
		// обращаться к полю instance лишь из свойства Instance
		internal static readonly Singleton instance = new Singleton();
	}
}

void Main() { }

//У всех представленных реализаций есть несколько важных особенностей.
// 1.Обработка исключений. 
// Поскольку инициализация синглтона происходит в статическом конструкторе,
// то в случае генерации исключения все клиенты получат его «завернутым»
// в TypeInitializationException. И, в отличие от предыдущих реализаций,
// попытка инициализации синглтона будет лишь одна.
// 2. Время создания синглтона.
// Если «забыть» пустой статический конструктор, то время инициализации
// синглтона станет недетерминированным. Если у типа не определен 
// статический конструктор явно, то компилятор помечает тип атрибутом
// beforeFieldInit, что позволит вызвать сгенерированный статический 
// конструктор отложенным (relaxed) образом задолго до первого 
// обращения к синглтону.
//Так, cинглтон будет проинициализирован еще до вызова метода Main, даже 
//если условие не будет выполняться во время исполнения.
//
//static void Main(string[] args)
//{
//	Console.WriteLine("Starting Main...");
//	if (args.Length == 1)
//	{
//		var s = SingletonWithoutStaticCtor.Instance;
//	}
//	Console.ReadLine();
//}
//3. «Ленивость».
// Эта реализация не полностью «ленива». Инициализация такого синглтона
// происходит во время вызова статического конструктора, который может 
// быть вызван не только при использовании синглтона, но и при обращении 
// к статическому члену этого класса.

//Достоинство: 
// относительная простота реализации. 
//Недостатки:
// особенности генерации исключений;
// возможные проблемы с «ленивостью» (без вложенного класса);
// проблемы с временем инициализации при отсутствии статического конструктора.

<Query Kind="Program" />

#region Создание и инициализация объекта!!!
//1. EE(Execution Engine)  выделяет память под объект. В общем случае эта операция сводится к сдвигу 
//указателя на начало свободной области в эфемерном сегменте. Если в свободной области
//недостаточно места для размещения нового объекта, инициируется сборка мусора 
//(чаще всего нулевого поколения). Выделяемый участок памяти инициализирован нулями,
//так что все ссылочные поля автоматически получают значение null.
//
//2. EE инициализирует указатель на таблицу методов. Фактически после этого этапа
//объект является полноценным живым объектом. Однако на этом этапе на объект еще нет 
//жестких ссылок, так что исключение внутри конструктора (если до этого не будет
//сделана жесткая ссылка) приведет к тому, что только что созданный объект автоматически
//будет считаться мусором. После этого действия у объекта уже можно вызвать виртуальные
//методы. Так что вызов виртуального метода в конструкторе некоторого базового
//класса может привести к вызову переопределенного в дочернем классе метода. Это поведение
//отличается от поведения, принятого в C++, так что C++-программистам стоит обратить
//на это особое внимание. Надо понимать, что вызов этот будет производиться еще до
//выполнения тела конструктора дочернего класса, так что, переопределяя методы, 
//вызываемые из конструктора, нужно быть осторожным и не рассчитывать на инициализацию,
//производимую в конструкторе. Хорошей идеей будет также отказаться от дизайна, 
//основанного на вызове виртуальных методов из конструктора. И вообще, лучше избегать
//всего, что может удивить пользователей ваших классов.
//
//3. EE закладывает указатель на объект в регистр ecx и передает управление конструктору,
//указанному в инструкции newobj, породившей генерацию кода создания объекта. Регистр ecx 
//используется по той причине, что по соглашению fastcall (используемому в .NET для вызова
//методов по умолчанию) через него передается первый параметр функции. Для экземплярных 
//методов первым параметром всегда является ссылка на this.
//
//4. Если во время работы конструктора не произошло необработанных исключений, то ссылка
//на объект помещается в ту или иную переменную области видимости, из которой вызывался
//код создания объектов. Сама переменная при этом может быть как локальной, располагаясь
//в регистре процессора или стеке, так и полем (статическим или полем экземпляра). 
//В общем-то, размещение ссылки в первой переменной не являются частью процесса создания
//объекта. С точки зрения MSIL, после создания объекта ссылка помещается на вершину 
//подразумеваемого стека виртуальной машины. Что дальше будет происходить со ссылкой,
//EE уже не интересует. Но фактически до размещения ссылки во внешней переменной процесс
//создания объекта еще не является законченным.
#endregion
//https://msdn.microsoft.com/ru-ru/library/ms173149.aspx
void Main()
{
	Derived d = new Derived();
	d.Dump();
}

class Base
{
	private int x = F1();
	
	public Base()
	{
		F2();
	}
	
	public static int F1()
	{
		"Base.F1.static".Dump();
		return 0;
	}
	
	public void F2()
	{
		"Base.F2".Dump();
	}
}

class Derived : Base
{
	private int x = F3();
	
	public Derived()
	{
		F4();
	}
	
	public static int F3()
	{
		"Derived.F3.static".Dump();
		return 0;
	}
	
	public void F4()
	{
		"Derived.F4".Dump();
	}
}
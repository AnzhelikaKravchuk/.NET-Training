<Query Kind="Program">
  <Reference>&lt;RuntimeDirectory&gt;\System.Runtime.Serialization.dll</Reference>
  <Namespace>System.Collections.ObjectModel</Namespace>
  <Namespace>System.Runtime.Serialization</Namespace>
  <Namespace>System.Runtime.Serialization.Json</Namespace>
  <Namespace>System.Xml.Serialization</Namespace>
</Query>

#region Создание и инициализация объекта!!!
//1. EE(Execution Engine)  выделяет память под объект. В общем случае эта операция 
//сводится к сдвигу указателя на начало свободной области в эфемерном сегменте.
//Если в свободной области
//недостаточно места для размещения нового объекта, инициируется сборка мусора 
//(чаще всего нулевого поколения). Выделяемый участок памяти инициализирован нулями,
//так что все ссылочные поля автоматически получают значение null.
//
//2. EE инициализирует указатель на таблицу методов. Фактически после этого этапа
//объект является полноценным живым объектом. Однако на этом этапе на объект еще нет 
//жестких ссылок, так что исключение внутри конструктора (если до этого не будет
//сделана жесткая ссылка) приведет к тому, что только что созданный объект автоматически
//будет считаться мусором. После этого действия у объекта уже можно вызвать виртуальные
//методы. Так что вызов виртуального метода в конструкторе некоторого базового
//класса может привести к вызову переопределенного в дочернем классе метода. Это поведение
//отличается от поведения, принятого в C++, так что C++-программистам стоит обратить
//на это особое внимание. Надо понимать, что вызов этот будет производиться еще до
//выполнения тела конструктора дочернего класса, так что, переопределяя методы, 
//вызываемые из конструктора, нужно быть осторожным и не рассчитывать на инициализацию,
//производимую в конструкторе. Хорошей идеей будет также отказаться от дизайна, 
//основанного на вызове виртуальных методов из конструктора. И вообще, лучше избегать
//всего, что может удивить пользователей ваших классов.
//
//3. EE закладывает указатель на объект в регистр ecx и передает управление конструктору,
//указанному в инструкции newobj, породившей генерацию кода создания объекта. Регистр ecx 
//используется по той причине, что по соглашению fastcall (используемому в .NET для вызова
//методов по умолчанию) через него передается первый параметр функции. Для экземплярных 
//методов первым параметром всегда является ссылка на this.
//
//4. Если во время работы конструктора не произошло необработанных исключений, то ссылка
//на объект помещается в ту или иную переменную области видимости, из которой вызывался
//код создания объектов. Сама переменная при этом может быть как локальной, располагаясь
//в регистре процессора или стеке, так и полем (статическим или полем экземпляра). 
//В общем-то, размещение ссылки в переменной не являются частью процесса создания
//объекта. С точки зрения MSIL, после создания объекта ссылка помещается на вершину 
//подразумеваемого стека виртуальной машины. Что дальше будет происходить со ссылкой,
//EE уже не интересует. Но фактически до размещения ссылки во внешней переменной процесс
//создания объекта еще не является законченным.
#endregion

void Main()
{
	Person p = new Person("Abc","Abc",12);
	p.Dump();
}

class Person 
{
	private string firstName;
	private string lastName;
	private int age;
	
	public Person(string firstName, string lastName, int age)
	{
		this.firstName = firstName;
		this.lastName = lastName;
		this.age = age;
	}
}